#!/usr/bin/env python
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

DOCUMENTATION = r'''
---
module: hpe_oneview_server_profile_reapply

short_description: This module is used to reapply a Server Profile/s on HPE OneView.

version_added: "1.0.0"

description: It makes use of the http 'requests' Python Module to interact with the HPE OneView API and triggers a reapply of a Server Profile/s.
# NB!
# The Server Profile reapply operation is an asynchronous operation. The operation is accepted and the response is returned immediately. The operation continues in the background.
# Login to the HPE OneView Appliance to monitor the progress of the reapply operation.
# Or use ansible to monitor the progress of the reapply operation.
# NB!!!
# In order for a server profile to be re-applied, the server hardware needs to be Powered Off.

options:
    appliance:
        description: The IP address OR the FQDN of the HPE OneView Appliance.
        required: true
        type: str
    ssl_enable:
        description: Enable or disable SSL verification.
        required: false
        type: bool
        choices: [true, false]
        default: true
    ssl_cert_filepath:
        description: The path to the SSL certificate file.
        required: false
        type: str
    auth_domain:
        description: The authentication domain to use when authenticating with the HPE OneView appliance.
        required: false
        type: str
        choices: ['local', 'ldap']
        default: 'local'
    username:
        description: The username to authenticate with on the HPE OneView appliance.
        required: true
        type: str
    password:
        description: The password to authenticate with on the HPE OneView appliance.
        required: true
        type: str
        no_log: true
        # we don't want to log the password in the output of the module.
    server_profile_name:
        description: The name of the Server Profile to reapply.
        required: true
        type: str
    reapply_data:
        description: The http json data (parsed in a list as there a multiple components of a server profile that we need to reapply) to use when reapplying the Server Profile.
        # refer to URL:
        # https://oneview.itservices.lan/api-docs/current/#rest/server-profiles
        required: false
        type: list

author:
    - John Paulsen (john.paulsen@odido.nl)
'''

EXAMPLES = r'''
- name: Reapply a Server Profile
  hpe_oneview_server_profile_reapply:
    appliance: oneview.itservices.lan
    ssl_enable: true
    ssl_cert_filepath: /etc/ssl/certs/itservices.lan-ca.crt
    auth_domain: local
    username: user
    password: password
    server_profile_name: Test-Server-Profile
    # reapply_data:
    #   - op: replace
    #     path: /firmware/reapplyState
    #     value: ApplyPending
    #   - op: replace
    #     path: /serverHardwareReapplyState
    #     value: ApplyPending
    #   - op: replace
    #     path: /bios/reapplyState
    #     value: ApplyPending
    #   - op: replace
    #     path: /managementProcessor/reapplyState
    #     value: ApplyPending

    # The reapply_data list defined above currently does not work.
    # It's a placeholder for future development.
    # At present, we hardcode the http json data in this module.
'''

RETURN = r'''
# These are examples of possible return values.
messages:
    description: List of 'INFO' type messages generated by the module.
    type: list
    returned: always
    sample: [
        'Succesfully obtained a Session ID',
        'Succesfully obtained the UUID: 'b1b1b1b1-b1b1-b1b1-b1b1-b1b1b1b1b1b1' for Server Profile: 'Test-Server-Profile',
    ]
exceptions:
    description: List of 'ERROR' type messages generated by the module.
    type: list
    returned: always
    sample: [
        'FAILED to obtain a Session ID',
        'Check that the username and password are correct',
        'Status Code: '404',
        'Failed to obtain the UUID for Server Profile: 'Test-Server-Profile',
        'Status Code: '400',
        'Failed to issue a re-apply of the Server Profile: 'Test-Server-Profile' with UUID: 'b1b1b1b1-b1b1-b1b1-b1b1-b1b1b1b1b1b1',
    ]
'''

# TODO:
# - Change the messages and exceptions params to dictionary params.
#   The Key value should be the name of the method that generated the message or exception.
# - See Jira story:
#   https://odido.atlassian.net/browse/LINOPS-5619
# - Fix the reapply_data param to work as expected.
# - Look into cleaning up OneView Sessions after use.

from ansible.module_utils.basic import AnsibleModule
import requests, json

headers = {
    'Accept': 'application/json',
    'Content-Type': 'application/json'
}

def get_oneview_session(appliance, ssl_enable, ssl_cert_filepath, headers, auth_domain, username, password):
    api_version = None
    session_id = None
    ssl_method = None
    messages = []
    exceptions = []
    failed = False
    return_dict = {}
    auth_data = {
        'authLoginDomain': auth_domain,
        'userName': username,
        'password': password
    }
    auth_data_json = json.dumps(auth_data)
    session_appliance = appliance
    method_headers = headers

    if ssl_enable:
        if ssl_cert_filepath:
            ssl_method=ssl_cert_filepath
        else:
            failed = True
            exception_message = "Error:\n"+"ssl_cert_filepath is required when ssl_enable is set to true."
            print(exception_message)
            exceptions.append(exception_message)
    else:
        ssl_method=False
    
    api_version_url = "https://{}/rest/version".format(appliance)
    if not failed:
        try:
            rg = requests.get(api_version_url, headers=method_headers, verify=ssl_method)
        except Exception as e:
            failed = True
            exception_message = "Error:\n"+str(e)
            print(exception_message)
            exceptions.append(exception_message)
            # exit(1)
        
        session_url = "https://{}/rest/login-sessions".format(appliance)
        try:
            api_version = rg.json()['currentVersion']
            method_headers['X-API-Version'] = str(api_version)
            rp = requests.post(session_url, headers=method_headers, data=auth_data_json, verify=ssl_method)
            session_id = rp.json()['sessionID']
            result_message = "Succesfully obtained a Session ID"
            print(result_message)
            messages.append(result_message)
        except Exception as e:
            failed = True
            exception_message = "Failed to obtain a Session ID"
            print(exception_message)
            exceptions.append(exception_message)
            exception_message = "Check that the username and password are correct"
            print(exception_message)
            exceptions.append(exception_message)
            exception_message = "Error:\n"+str(e)
            print(exception_message)
            exceptions.append(exception_message)
            # exit(1)

    return_dict['api_version'] = api_version
    return_dict['session_appliance'] = session_appliance
    return_dict['session_id'] = session_id
    return_dict['ssl_method'] = ssl_method
    return_dict['messages'] = messages
    return_dict['exceptions'] = exceptions
    return_dict['failed'] = failed

    return return_dict


def reapply_server_profile(session_appliance, api_version, session_id, headers, ssl_method, server_profile_name, reapply_data):
    messages = []
    exceptions = []
    failed = False
    return_dict = {}
    server_profile_uuid = None
    method_headers = headers
    method_headers['Auth'] = session_id
    method_headers['X-API-Version'] = str(api_version)
    server_profile_filter_url = "https://{}/rest/server-profiles/?filter=\"name EQ '{}'\"".format(session_appliance, server_profile_name)

    try:
        rg = requests.get(server_profile_filter_url, headers=method_headers, verify=ssl_method)
    except Exception as e:
        failed = True
        exception_message = "Error:\n"+str(e)
        print(exception_message)
        exceptions.append(exception_message)
        # exit(1)
    
    if rg.status_code == 200:
        server_profile_uuid = rg.json()['members'][0]['profileUUID']
        messages.append("Status Code: '{}'".format(rg.status_code))
        messages.append("Succesfully obtained the UUID: '{}' for Server Profile: '{}'".format(server_profile_uuid, server_profile_name))
    else:
        failed = True
        response_body = {}
        exceptions.append("Status Code: '{}'".format(rg.status_code))
        exceptions.append("Failed to obtain the UUID for Server Profile: '{}'".format(server_profile_name))
        for attr in dir(rg):
                print(str(attr))
                response_body[str(attr)] = str(getattr(rg, attr))
        exceptions.append(response_body)
        # exit(1)
    
    if not failed:
        reapply_profile_url = "https://{}/rest/server-profiles/{}".format(session_appliance, server_profile_uuid)
        try:
            rp = requests.patch(reapply_profile_url,
                                       headers=method_headers,
                                       data=reapply_data,
                                       verify=ssl_method
                                    )
            
            if rp.status_code == 202 or rp.status_code == 200:
                messages.append("Status Code: '{}'".format(rp.status_code))
                messages.append("Succesfully issued a re-apply request the Server Profile: '{}' on HPE OneView: '{}'".format(server_profile_name, session_appliance))
            else:
                failed = True
                response_body = {}
                exceptions.append("Status Code: '{}'".format(rp.status_code))
                exceptions.append("Failed to issue a re-apply of the Server Profile: '{}' with UUID: '{}'".format(server_profile_name, server_profile_uuid))
                for attr in dir(rp):
                    print(str(attr))
                    response_body[str(attr)] = str(getattr(rp, attr))
                exceptions.append(response_body)
                # exit(1)
    
        except Exception as e:
            failed = True
            exception_message = "Error:\n"+str(e)
            print(exception_message)
            exceptions.append(exception_message)
            # exit(1)

    return_dict['messages'] = messages
    return_dict['exceptions'] = exceptions
    return_dict['failed'] = failed
    
    return return_dict


def run_module():
    module_args = dict(
        appliance=dict(type='str', required=True),
        ssl_enable=dict(type='bool', required=False, default=True),
        ssl_cert_filepath=dict(type='str', required=False),
        auth_domain=dict(type='str', required=False, default='local', choices=['local', 'ldap']),
        username=dict(type='str', required=True),
        password=dict(type='str', required=True, no_log=True),
        server_profile_name=dict(type='str', required=True),
        reapply_data=dict(type='list', required=False)
    )

    # seed the result dict in the object we primarily care about
    # changed and state changed is if this module effectively modified the target
    # state will include any data that we want this module to pass back
    # for consumption, for example, in a subsequent task
    result = dict(
        changed=False,
        messages=[],
        exceptions=[],
        rc=0
    )

    # the AnsibleModule object will be our abstraction working with Ansible
    # this includes instantiation, a couple of common attr would be the
    # args/params passed to the execution, as well as if the module
    # supports check mode
    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )

    result_exceptions = []
    result_messages = []

    # if the user is working with this module in only check mode we do not
    # want to make any changes to the environment, just return the current
    # state with no modifications
    if module.check_mode:
        module.exit_json(**result)

    # login to the OneView Appliance and set session variables
    oneview_session = get_oneview_session(module.params['appliance'], module.params['ssl_enable'], module.params['ssl_cert_filepath'], headers, module.params['auth_domain'], module.params['username'], module.params['password'])
    
    if oneview_session['failed']:
        result['changed'] = False
        if len(oneview_session['exceptions']) > 0:
            result_exceptions.append(oneview_session['exceptions'])
            result['exceptions'] = result_exceptions
        if len(oneview_session['messages']) > 0:
            result_messages.append(oneview_session['messages'])
            result['messages'] = result_messages
        result['rc'] = 1
        module.fail_json(msg="failed to login / establish session to the OneView Appliance: ''".format(module.params['appliance']), **result)
    else:
        if len(oneview_session['messages']) > 0:
            result_messages.append(oneview_session['messages'])
            result['messages'] = result_messages

    # re-apply the Server Profile
    # http_data = str(module.params['reapply_data'])
    # This currently does not work as expected.
    # hardcoding the http json data for now.
    http_data = '[{"op" : "replace", "path" : "/firmware/reapplyState", "value" : "ApplyPending"}, {"op" : "replace", "path" : "/serverHardwareReapplyState", "value" : "ApplyPending"}, {"op" : "replace", "path" : "/bios/reapplyState", "value" : "ApplyPending"}, {"op" : "replace", "path" : "/managementProcessor/reapplyState", "value" : "ApplyPending"}]'

    reapply_result = reapply_server_profile(oneview_session['session_appliance'], oneview_session['api_version'], oneview_session['session_id'], headers, oneview_session['ssl_method'], module.params['server_profile_name'], http_data)

    if reapply_result['failed']:
        result['changed'] = False
        if len(reapply_result['exceptions']) > 0:
            result_exceptions.append(reapply_result['exceptions'])
            result['exceptions'] = result_exceptions
        if len(reapply_result['messages']) > 0:
            result_messages.append(reapply_result['messages'])
            result['messages'] = result_messages
        result['rc'] = 1
        module.fail_json(msg='failed to reapply the Server Profile: {}'.format(module.params['server_profile_name']), **result)
    else:
        result['changed'] = True
        if len(reapply_result['messages']) > 0:
            result_messages.append(reapply_result['messages'])
            result['messages'] = result_messages

    # in the event of a successful module execution gracefully exit, passing the key/value results
    module.exit_json(**result)


def main():
    run_module()

if __name__ == '__main__':
    main()
